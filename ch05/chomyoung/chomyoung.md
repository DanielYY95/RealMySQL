### 용어

- Lock(잠금): 서로 다른 작업에서 같은 자원을 동시에 필요로 할 때 자원 경쟁이 일어나는데, 이때 순서대로 사용되는 **`동시성을 보장`**하기 위한 기능
- 격리 수준: 격리 수준은 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지 결정하는 레벨

# **트랜잭션**

## 트랜잭션이란?

- 기본 정의: 논리적인 작업 단위
- 목표: **데이터베이스의 일관성 유지**와 **안전한 데이터 처리**를 보장(**데이터 무결성 보장**)
- 하나의 작업 세트가 일부만 적용되지 않도록 함을 보장(**`작업의 완전성`** 보장)
    - 전부 commit 혹은 rollback

## 주의사항

- 트랜잭션은 꼭 필요한 최소의 코드에만 적용
    - 이유
        1. DB의 커넥션 수가 제한적이기에 자원을 효율적 관리 - **`설명1`**
        2. Lock의 유지 시간 최소화 ⇒ DB 성능 유지 - **`설명2`**
- 네트워크 작업이 있는 경우에는 반드시 트랜잭션에서 배제!
- 다른 성격의 작업은 트랜잭션 분리

# **MySQL 엔진의 잠금**

- 크게 MySQL 엔진 레벨과 스토리지 엔진 레벨로 나눌 수 있다.

### 1. 글로벌 락

- MySQL에서 제공하는 잠금 가운데 가장 범위가 크다.
- 정의: 모든 데이터베이스의 모든 테이블에 대해 쓰기 작업을 막는 Lock
- 대상: MySQL 서버 전체를 대상으로 Lock 설정
- 사용 예시: 주로 백업을 위한 목적이나 대규모 데이터를 조작하는 작업 중 데이터 무결성을 보장하기 위해 사용

### 2. 테이블 락

- 정의: 테이블 단위로 읽기 또는 쓰기 작업을 제한
- 대상: 개별 테이블 단위로 설정되는 Lock 설정
- 사용 예시: 여러 트랜잭션이 동시에 특정 테이블에 접근할 때 충돌을 방지하거나, 테이블에 대한 대량 작업을 수행할 때 사용

### 3. 네임드 락

- 정의: 지정한 문자열 이름에 따라 락을 설정하고 해제하여 **`여러 웹 서버가 동일한 리소스에 동시 접근하지 않도록 관리`**
    - 잠금을 설정한 문자열에 대해 동일한 락을 요청하는 다른 트랜잭션은 락이 해제될 때까지 대기
- 대상: 사용자가 지정한 임의의 문자열에 대해 Lock 설정
- 사용 예시:  1대의 서버에 여러 웹 서버가 접속하는 서비스에서 여러 웹 서버가 어떤 정보를 동기화 하는 경우
    - 네임드 락을 사용하면 하나의 서버만 해당 리소스에 접근할 수 있게 하여 경쟁상태를 방지할 수 있고, 타임아웃 기능 또한 제공하여 deadlock방지에 기여

### 4. 메타데이터 락

- 정의: 테이블의 스키마 변경, 인덱스 추가 등과 같은 작업 중 데이터 충돌을 방지하기 위해 사용
- 대상: 데이터베이스 객체(예: 테이블, 뷰 등)의 이름이나 구조를 변경할 때, 해당 객체에 설정되는 Lock
- 사용 예시: 테이블의 스키마 변경, 인덱스 추가 등과 같은 작업 중 데이터 충돌을 방지 ex) RENAME TABLE @@@

# **InnoDB 스토리지 엔진의 잠금**

<aside>
💡

레코드 기반의 잠금 기능을 제공 ⇒ 동시성 처리가 매우 뛰어나다.

**why? 잠금 범위를 최소화**하고, 트랜잭션 간 **병목 현상을 줄이며**, **데드락을 방지**하면서도 **동시 읽기 및 쓰기 작업을 병행**할 수 있기 때문에
**`설명3`**

</aside>

### 1. 레코드 락

- 정의: 레코드 자체가 아닌 인덱스의 레코드를 잠근다.
    - 인덱스 생성을 안했어도 **`자동 생성되는 클러스터 인덱스`**를 이용
- 대상: 특정 레코드(행)에 대해 Lock 설정 ⇒ 동시성이 높은 환경에서 충돌을 최소화하고 특정 행에 대한 안전한 접근을 보장
- 사용예시

    ```jsx
    -- 특정 레코드에 대해 잠금을 설정하는 트랜잭션
    START TRANSACTION;
    SELECT * FROM orders WHERE order_id = 123 FOR UPDATE;
    -- 해당 레코드에 대해 업데이트 작업 수행
    UPDATE orders SET status = 'processed' WHERE order_id = 123;
    COMMIT;
    
    // FOR UPDATE 구문을 사용하여 특정 레코드에 대해 락을 설정한 후 업데이트 작업을 수행
    // => 동시에 여러 트랜잭션이 같은 레코드를 변경하지 않도록 보호
    ```

- 설명: **`설명4`**

### 2. 갭 락

- 정의: 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어
- 대상: 레코드와 바로 인접한 레코드 사이의 간격만을 Lock 설정
- 사용예시: 갭 락 자체 보단 넥스트 키 락의 일부로 자주 사용된다.

### 3. 넥스트 키 락

- 정의: 바이너리 로그에 기록되는 쿼리가 Replica 서버에서 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를 만들어내도록 보장
- 대상: 레코드 락과 갭락을 합친 Lock
    - 이는 트랜잭션이 실행되는 동안, 다른 트랜잭션이 해당 범위 내에서 레코드를 추가하거나 삭제하는 것을 방지
- 사용예시

    ```jsx
    SELECT * FROM employees WHERE id BETWEEN 100 AND 200 FOR UPDATE;
    // id가 100에서 200 사이인 레코드들뿐만 아니라, 그 사이의 갭도 잠금으로 보호
    // 이를 통해 다른 트랜잭션이 해당 범위 내에서 레코드 추가, 삭제 방지
    ```


### 4. 자동 증가 락

- 정의: AUTO_INCREMENT 칼럼이 사용된 테이블에 여러 레코드가INSERT 될 경우 각 레코드는 중복x, 순차적인 값을 가져야하는데 이를 보장하기 위해 사용되는 Lock 방식 ⇒ 중복되지 않는 ID 값을 안전하게 할당
- 대상: **AUTO_INCREMENT**를 사용하는 **컬럼**에 대한 Lock
- 사용예시

    ```jsx
    -- AUTO_INCREMENT가 설정된 테이블에 대해 여러 레코드 삽입
    INSERT INTO orders (product_id, quantity) VALUES (1, 100), (2, 50);
    
    // 여러 트랜잭션이 동시에 orders 테이블에 데이터를 삽입할 때, 
    // 각 레코드는 자동 증가 락을 통해 pk(고유한 주문번호) 부여
    // MySQL은 이 과정에서 자동으로 락을 설정하여 중복된 값이 할당되지 않도록 보장
    ```


# **MySQL의 격리 수준**

| Dirty Read | Non-Repeatable Read | Phantom Read |
| --- | --- | --- |
| Read Uncommitted | 발생 | 발생 |
| Read Committed | 없음 | 발생 |
| Repeatable Read | 없음 | 없음 |
| Serializable | 없음 | 없음 |

# 설명란

### 설명1

- DB 커넥션 풀은 애플리케이션과 DB 간의 연결을 관리하는 시스템으로서, DB와 연결된 커넥션을 일정 수만큼 미리 열어두고 app에서 요청 시 이를 할당
- 트랜잭션이 시작되면, 데이터베이스에 연결된 커넥션이 잠긴다. 이 커넥션은 트랜잭션이 완료될 때까지 다른 요청에 사용되지 못한다.
- 결국 새로운 요청이 들어왔을 때 사용할 수 있는 커넥션이 부족해지면서 **`병목 현상`**이 발생

### 설명2

- 트랜잭션이 진행되는 동안 데이터베이스는 Lock을 사용하여 데이터를 보호. 즉, 트랜잭션이 완료될 때까지 특정 테이블이나 row가 다른 트랜잭션에 의해 변경되지 않도록 잠금

  ⇒ 트랜잭션이 길어지면 다른 트랜잭션이 해당 데이터에 접근하지 못하게 되어 **데이터베이스 성능 저하**를 초래


### 동시성 문제 ~ 트랜잭션

- 동시성 문제: 여러 스레드나 프로세스가 **동시에 같은 자원**에 접근하거나 수정하려고 할 때 발생하는 문제
- 여러 트랜잭션이 동시에 같은 데이터에 접근할 때, 트랜잭션의 **격리 수준**에 따라 동시성 문제가 발생할 수 있다.
- 이를 방지하기위해 DB에서 Lock 혹은 트랜잭션 격리 수준을 설정하지만, 잘못 설정하면 데이터 일관성이 깨질 수 있다.
    - 더티 리드(Dirty Read), 반복 불가능한 읽기(Non-Repeatable Read), 팬텀 리드(Phantom Read)와 같은 동시성 문제 발생
        - **더티 리드(Dirty Read - READ UNCOMMITTED)**: 한 트랜잭션이 아직 커밋되지 않은 데이터를 읽는 경우.
        - **반복 불가능한 읽기(Non-repeatable Read - READ COMMITTED)**: 한 트랜잭션이 데이터를 읽은 후, 다른 트랜잭션이 그 데이터를 수정하면, 처음 읽은 값과 나중에 읽은 값이 달라지는 경우.
        - **팬텀 리드(Phantom Read - REPEATABLE READ)**: 한 트랜잭션이 데이터를 조회한 후, 다른 트랜잭션이 그 사이에 새로운 데이터를 삽입하여, 다시 조회할 때 데이터가 변경되는 경우.
    - 추가로, **SERIALIZABLE 격리수준**에서는 동시성 성능이 크게 저하될 수 있다.
    - Lock은 범위가 너무 넓으면 성능 저하, 제대로 해제하지않으면 DeadLock 발생 가능성(무한 대기)

### 동시성을 제어해야하는 이유

- **Race condition**
    - 두 개 이상의 스레드가 동시에 같은 데이터를 접근하여 값을 변경하고자 할 때, 데이터의 예상치 못한 변경이 발생할 수 있다.
- **DeadLock**
    - 두 개 이상의 스레드가 서로의 작업이 완료될 때까지 기다리면서 결국 아무도 완료되지 않는 문제가 발생할 수 있다.
- **Data corruption**
    - 두 개 이상의 스레드가 동시에 같은 데이터에 접근하여 값을 변경할 때, 예상치 못한 데이터의 변형이 발생할 수 있다.

### 설명3

### 설명4

- 인덱스와 Lock
    - 인덱스가 적절히 설정되어 있지 않으면 잠금의 범위가 커져서 동시성이 떨어진다.
    - 만약 아예 인덱스가 없다면 테이블을 Full Scan하며 UPDATE 작업을 하는데 이 과정에서 모든 레코드를 잠근다.

      ⇒ 잠금의 범위를 최소화할 수 있도록 인덱스 설계를 잘 해야한다

- **`자동 생성되는 클러스터 인덱스`**